use serde::{Deserialize, Serialize};

use crate::entities::cyclonedx::Component;
use crate::entities::sboms::CdxFormat;
use crate::Error;

/*
 * Generated by: https://openapi-generator.tech
 */

pub fn default_id() -> String {
    String::from("")
}

#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct Bom {
    // WARN: Added for Mongo Storage.
    #[serde(default = "default_id")]
    pub id: String,
    #[serde(rename = "$schema", skip_serializing_if = "Option::is_none")]
    pub dollar_schema: Option<DollarSchema>,
    /// Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be \"CycloneDX\".
    #[serde(rename = "bomFormat")]
    pub bom_format: BomFormat,
    /// The version of the CycloneDX specification a BOM conforms to (starting at version 1.2).
    #[serde(rename = "specVersion")]
    pub spec_version: String,
    /// Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM have not changed over time. If specified, the serial number MUST conform to RFC-4122. Use of serial numbers are RECOMMENDED.
    #[serde(rename = "serialNumber", skip_serializing_if = "Option::is_none")]
    pub serial_number: Option<String>,
    /// Whenever an existing BOM is modified, either manually or through automated processes, the version of the BOM SHOULD be incremented by 1. When a system is presented with multiple BOMs with identical serial numbers, the system SHOULD use the most recent version of the BOM. The default version is '1'.
    #[serde(rename = "version")]
    pub version: i32,
    #[serde(rename = "metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Box<crate::entities::cyclonedx::Metadata>>,
    /// A list of software and hardware components.
    #[serde(rename = "components", skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<crate::entities::cyclonedx::models::Component>>,
    /// A list of services. This may include microservices, function-as-a-service, and other types of network or intra-process services.
    #[serde(rename = "services", skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<crate::entities::cyclonedx::models::Service>>,
    /// External references provide a way to document systems, sites, and information that may be relevant but which are not included with the BOM.
    #[serde(rename = "externalReferences", skip_serializing_if = "Option::is_none")]
    pub external_references: Option<Vec<crate::entities::cyclonedx::models::ExternalReference>>,
    /// Provides the ability to document dependency relationships.
    #[serde(rename = "dependencies", skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<Vec<crate::entities::cyclonedx::models::Dependency>>,
    /// Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness.
    #[serde(rename = "compositions", skip_serializing_if = "Option::is_none")]
    pub compositions: Option<Vec<crate::entities::cyclonedx::models::Compositions>>,
    /// Vulnerabilities identified in components or services.
    #[serde(rename = "vulnerabilities", skip_serializing_if = "Option::is_none")]
    pub vulnerabilities: Option<Vec<crate::entities::cyclonedx::models::Vulnerability>>,
    #[serde(rename = "signature", skip_serializing_if = "Option::is_none")]
    pub signature: Option<serde_json::Value>,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DollarSchema {
    #[serde(rename = "http://cyclonedx.org/schema/bom-1.4.schema.json")]
    Version1_4,
}

impl Default for DollarSchema {
    fn default() -> DollarSchema {
        Self::Version1_4
    }
}
/// Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be \"CycloneDX\".
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum BomFormat {
    #[serde(rename = "CycloneDX")]
    CycloneDx,
}

impl Default for BomFormat {
    fn default() -> BomFormat {
        Self::CycloneDx
    }
}

impl Bom {
    pub fn new(bom_format: BomFormat, spec_version: String, version: i32) -> Bom {
        Bom {
            id: "".to_string(),
            dollar_schema: None,
            bom_format,
            spec_version,
            serial_number: None,
            version,
            metadata: None,
            components: None,
            services: None,
            external_references: None,
            dependencies: None,
            compositions: None,
            vulnerabilities: None,
            signature: None,
        }
    }

    /// Compares Bom instances for equality.
    pub fn eq(&self, _other: &mut Bom) -> Result<bool, Error> {
        // This function has to remove known variable values before comparing, for example timestamps.
        // first.metadata?.timestamp = None;
        // second.metadata?.timestamp = None;
        //
        // first_raw = serde_json::to_string(first);
        // second_raw = serde_json::to_string(second);

        // TODO
        Ok(false)
    }

    /// Parses a raw string into a CycloneDx Bom instance.
    pub fn parse(raw: &str, format: CdxFormat) -> Result<Bom, Error> {
        match format {
            CdxFormat::Json => {
                let bom = serde_json::from_str::<Bom>(raw).map_err(|e| {
                    Error::Serde(format!("error serializing CycloneDx SBOM - {}", e))
                })?;

                Ok(bom)
            }
            CdxFormat::Xml => Err(Error::Runtime("CycloneDx XML not supported".to_string())),
        }
    }

    /// Extracts the Component for the Bom.
    pub fn component(&self) -> Option<Component> {
        self.metadata.clone()?.component.as_deref().cloned()
    }

    /// Extracts the Purl for the Bom.
    pub fn purl(&self) -> Option<String> {
        self.metadata.clone()?.component?.purl
    }
}
