use crate::Error;
use std::process::Command;

/// Executes an external shell command.
pub fn execute(cmd: &mut Command, name: &str) -> Result<String, Error> {
    let output = match cmd.output() {
        Ok(output) => output,
        Err(err) => {
            return Err(Error::Process(format!(
                "error executing command {} : {}",
                name, err
            )));
        }
    };

    // Handle error generated by command.
    if !&output.status.success() {
        match String::from_utf8(output.stderr) {
            Ok(stderr) => {
                Error::Process(format!("error in command {}: {}", name, &stderr));
            }
            Err(err) => {
                return Err(Error::Process(format!(
                    "error formatting {} stderr: {}",
                    name, &err
                )));
            }
        };
    }

    match String::from_utf8(output.stdout) {
        Ok(sbom) => Ok(sbom),
        Err(e) => Err(Error::Process(format!(
            "error reading {} stdout: {}",
            name, e
        ))),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Error;

    #[test]
    fn can_execute_command() -> Result<(), Error> {
        let mut cmd = Command::new("git");
        let cmd = cmd.arg("--version");

        let result = execute(cmd, "git")?;
        assert!(result.contains("git"));

        Ok(())
    }
}
