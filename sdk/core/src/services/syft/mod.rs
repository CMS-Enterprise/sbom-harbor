use crate::entities::cyclonedx::Bom;
use crate::Error;
use std::collections::HashMap;
use std::process::Command;

lazy_static! {
    /// Mop of Syft catalogers to package manager purl prefixes based on Syft
    /// [supported ecosystems](https://github.com/anchore/syft/blob/376c42893b38a68e9703470d9e625bf98612a1d4/README.md?plain=1#L488).
    static ref CATALOGERS: HashMap<&'static str, &'static str> = {
            HashMap::from([
            ("alpmdb-cataloger", "alpm"),
            ("apkdb-cataloger", "apk"),
            ("binary-cataloger", "binary"),
            ("cargo-auditable-binary-cataloger", "cargo"),
            ("cocoapods-cataloger", "cocoapods"),
            ("conan-cataloger", "conan"),
            ("dartlang-lock-cataloger", "pub"),
            ("dotnet-deps-cataloger", "nuget"),
            ("dpkgdb-cataloger", "deb"),
            ("elixir-mix-lock-cataloger", "hex"),
            ("erlang-rebar-lock-cataloger", "hex"),
            ("go-mod-file-cataloger", "golang"),
            ("go-module-binary-cataloger", "golang"),
            // ("graalvm-native-image-cataloger", ""),
            ("haskell-cataloger", "hackage"),
            ("java-cataloger", "maven"),
            ("java-gradle-lockfile-cataloger", "maven"),
            ("java-pom-cataloger", "maven"),
            ("javascript-lock-cataloger", "npm"),
            ("javascript-package-cataloger", "npm"),
            ("linux-kernel-cataloger", "generic"),
            ("nix-store-cataloger", "nix"),
            ("php-composer-installed-cataloger", "composer"),
            ("php-composer-lock-cataloger", "composer"),
            ("portage-cataloger", "ebuild"),
            ("python-index-cataloger", "pypi"),
            ("python-package-cataloger", "pypi"),
            ("rpm-db-cataloger", "rpm"),
            ("rpm-file-cataloger", "rpm"),
            ("ruby-gemfile-cataloger", "gem"),
            ("ruby-gemspec-cataloger", "gem"),
            ("rust-cargo-lock-cataloger", "cargo"),
            // ("sbom-cataloger", ""),
        ])
    };
}

/// Best-effort algorithm to determine the package manager for an Sbom generated by Syft.
pub fn try_extract_package_manager(bom: &Bom) -> String {
    // define a default so that we always succeed, but can easily identify records where we were
    // unable to resolve a best guess.
    let pkg_harbor = "pkg:harbor".to_string();

    // Deref the components so that we can inspect their catalogers.
    let components = match &bom.components {
        None => {
            return pkg_harbor;
        }
        Some(c) => {
            if c.is_empty() {
                return pkg_harbor;
            }
            c
        }
    };

    // Keep a count of each found cataloger.
    let mut catalogers: HashMap<&str, u16> = HashMap::new();

    // Inspect each component's properties.
    for component in components {
        // Move to next component if no properties.
        let properties = match &component.properties {
            None => continue,
            Some(p) => {
                if p.is_empty() {
                    continue;
                }
                p
            }
        };

        // Look for the cataloger property.
        for property in properties {
            // Skip to next property if not the cataloger property.
            let cataloger = match &property.name {
                None => continue,
                Some(n) => {
                    if n != "syft:package:foundBy" {
                        continue;
                    }
                    match &property.value {
                        None => "",
                        Some(cataloger) => cataloger.as_str(),
                    }
                }
            };

            // If we can resolve the cataloger, increment its count.
            if CATALOGERS.contains_key(cataloger) {
                match catalogers.contains_key(cataloger) {
                    true => {
                        *catalogers.get_mut(cataloger).unwrap() += 1;
                    }
                    false => {
                        catalogers.insert(cataloger, 1);
                    }
                }
            }

            // Stop iterating properties and move on to next component.
            break;
        }
    }

    // Find the cataloger with the highest count.
    let max_cataloger = catalogers
        .iter()
        .max_by(|a, b| a.1.cmp(b.1))
        .map(|(k, _v)| *k);

    let key = match max_cataloger {
        Some(key) => key,
        None => {
            return pkg_harbor;
        }
    };

    // Return the purl package manager abbreviation for the cataloger.
    let abbr = match CATALOGERS.get(key) {
        None => {
            return pkg_harbor;
        }
        Some(a) => a,
    };

    format!("pkg:{}", abbr)
}

/// Generates an SBOM by shelling out to the Syft CLI.
pub fn execute(source_path: &str, name: &str, version: &str) -> Result<String, Error> {
    let mut cmd = Command::new("syft");
    let cmd = cmd
        .arg("--output")
        .arg("cyclonedx-json")
        .arg(source_path)
        .arg("--source-name")
        .arg(name)
        .arg("--source-version")
        .arg(version);

    platform::process::execute(cmd, "syft").map_err(|e| Error::Sbom(format!("syft_error::{}", e)))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::entities::sboms::{Author, CdxFormat, Sbom};
    use crate::entities::xrefs::{Xref, XrefKind};
    use crate::testing::sbom_raw;
    use crate::Error;

    #[test]
    fn can_resolve_package_purl() -> Result<(), Error> {
        let raw = sbom_raw()?;

        let sbom = Sbom::from_raw_cdx(
            raw.as_str(),
            CdxFormat::Json,
            Author::Vendor("can_resolve_package_manager".to_string()),
            &None,
            Xref {
                kind: XrefKind::Product,
                map: HashMap::default(),
            },
            None,
        )?;

        match sbom.purl {
            None => {
                return Err(Error::Entity("could not resolve sbom purl".to_string()));
            }
            Some(purl) => {
                assert!(purl.starts_with("pkg:cargo"));
            }
        }

        Ok(())
    }
}
