use anyhow::{anyhow, bail, Result};
use chrono::Utc;
use git2::Repository;
use lambda_http::{Body, Error, Request, RequestExt, Response};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use std::path::Path;
use std::process::Command;
use tracing::{info, instrument};

use harbor_client::{Client, SBOMUploadResponse};

/// Implements the ServiceFn<T> interface expected by the Lambda runtime.
/// Provides protocol level validation, and then delegates to request handler.
#[instrument]
pub async fn function_handler(req: Request) -> Result<Response<Body>, Error> {
    // TODO: Provide shapely errors and meaningful HTTP status codes.
    let request: Option<PilotRequest> = req.payload()?;
    let request = match request {
        None => {
            return Err(Error::try_from(anyhow!("generate request required"))?);
        }
        Some(r) => r,
    };

    if let Err(err) = request.validate() {
        info!("{}", err);
        return Err(Error::try_from(anyhow!("Bad Request"))?);
    };

    let upload_resp = handle_request(request).await?;

    info!("generator complete with response: {:?}", upload_resp);

    let json_resp = serde_json::to_vec(&upload_resp)?;
    let resp_body = Body::from(json_resp);

    let resp: Response<Body> = Response::builder()
        .status(200)
        .header("content-type", "application/json")
        .body(resp_body)
        .map_err(Box::new)?;

    Ok(resp)
}

/// Clones a repo, generates an SBOM, and then uploads to the Enrichment Engine.
pub async fn handle_request(request: PilotRequest) -> Result<SBOMUploadResponse> {
    let clone_path = clone_path(&request.github_url);

    clone_repo(&clone_path, &request.github_url)?;

    let syft_result = syft(&clone_path)?;

    remove_clone(&clone_path)?;

    Client::upload_sbom(
        request.cloud_front_domain.as_str(),
        request.token.as_str(),
        request.team_id,
        request.project_id,
        request.codebase_id,
        syft_result,
    )
    .await
}

/// An HTTP request that contains the necessary configuration and authorization
/// to auto-generate and upload an SBOM.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PilotRequest {
    /// The team id for the request.
    #[serde(rename = "teamId")]
    pub team_id: String,

    /// The project id for the request.
    #[serde(rename = "projectId")]
    pub project_id: String,

    /// The codebase id for the request.
    #[serde(rename = "codebaseId")]
    pub codebase_id: String,

    /// The CloudFront Domain for the Harbor instance.
    #[serde(rename = "cloudFrontDomain")]
    pub cloud_front_domain: String,

    /// The API Gateway URL for the Harbor instance.
    #[serde(rename = "apiGatewayUrl")]
    pub api_gateway_url: Option<String>,

    /// A valid SBOM upload token for Harbor.
    #[serde(rename = "harborToken")]
    pub token: String,

    // TODO: Rename to clone_url.
    /// The HTTPS git URL for the repository.
    #[serde(rename = "gitHubUrl")]
    pub github_url: String,
}

impl PilotRequest {
    pub fn validate(&self) -> Result<()> {
        let mut errors: String = String::from("");

        if self.team_id.is_empty() {
            errors.push_str("teamId required\n");
        }

        if self.project_id.is_empty() {
            errors.push_str("projectId required\n");
        }

        if self.codebase_id.is_empty() {
            errors.push_str("codebaseId required\n");
        }

        if self.cloud_front_domain.is_empty() {
            errors.push_str("cloudFrontDomain required\n");
        }

        if self.token.is_empty() {
            errors.push_str("harborToken required\n");
        }

        if self.github_url.is_empty() {
            errors.push_str("gitHubUrl required\n");
        }

        if !errors.is_empty() {
            bail!("Invalid request parameters: {}", errors);
        }

        Ok(())
    }
}

// TODO: Make an enum with all possible formats, then make
// TODO: this a config option with default.
const CYCLONEDX_JSON_FORMAT: &str = "cyclonedx-json";

/// Invokes the syft CLI against the cloned repository to generate an SBOM.
pub fn syft(source_path: &str) -> Result<HashMap<String, Value>> {
    let output = match Command::new("syft")
        .arg("--output")
        .arg(CYCLONEDX_JSON_FORMAT)
        .arg(source_path)
        .output()
    {
        Ok(output) => output,
        Err(err) => {
            bail!("error executing syft cli: {}", err);
        }
    };

    // Handle error generated by syft.
    if !&output.status.success() {
        match String::from_utf8(output.stderr) {
            Ok(stderr) => {
                bail!("error generating SBOM: {}", &stderr);
            }
            Err(err) => {
                bail!("error formatting syft stderr: {}", &err);
            }
        };
    }

    if output.stdout.is_empty() {
        bail!("syft generated empty SBOM");
    };

    match serde_json::from_slice::<HashMap<String, Value>>(output.stdout.as_slice()) {
        Ok(result) => Ok(result),
        Err(err) => {
            bail!("error serializing SBOM to hash map: {}", err);
        }
    }
}

/// Generates a unique clone path for a repository.
pub fn clone_path(url: &str) -> String {
    // add a unique element to the path to prevent collisions.
    let timestamp = Utc::now().to_rfc3339();

    let repo_name = url
        .split('/')
        .collect::<Vec<&str>>()
        .pop()
        .unwrap()
        .replace(".git", "");

    format!("/tmp/{}/{}", timestamp, repo_name)
}

/// Clones a git repository to the specified clone path.
pub fn clone_repo(clone_path: &str, url: &str) -> Result<()> {
    info!("Cloning repo: {}", url);

    match Repository::clone(url, clone_path) {
        Err(err) => {
            bail!("error cloning repository from {}: {}", url, err);
        }
        _ => info!("Successfully cloned repo"),
    };

    Ok(())
}

/// Removes a cloned repository from the filesystem.
pub fn remove_clone(clone_path: &str) -> std::io::Result<()> {
    if Path::new(&clone_path).is_dir() {
        return std::fs::remove_dir_all(clone_path);
    }

    Ok(())
}
