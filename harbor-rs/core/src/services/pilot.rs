use crate::Error;
use aqum::hyper::{ContentType, post};
use chrono::Utc;
use git2::Repository;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::path::Path;
use std::process::Command;
use tracing::{info, instrument};

fn join_url(base: &str, route: &str) -> String {
    let mut url = base.to_owned();
    url.push_str(route);
    url
}

// TODO: Make an enum with all possible formats, then make
// TODO: this a config option with default.
const CYCLONEDX_JSON_FORMAT: &str = "cyclonedx-json";

/// An HTTP request that contains the necessary configuration and authorization
/// to auto-generate and upload an SBOM.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PilotContext {
    /// The team id for the request.
    #[serde(rename = "teamId")]
    pub team_id: String,

    /// The project id for the request.
    #[serde(rename = "projectId")]
    pub project_id: String,

    /// The codebase id for the request.
    #[serde(rename = "codebaseId")]
    pub codebase_id: String,

    /// The CloudFront Domain for the Harbor instance.
    #[serde(rename = "cloudFrontDomain")]
    pub cloud_front_domain: String,

    /// A valid SBOM Harbor token.
    pub token: String,

    /// A valid GitHub token.
    #[serde(rename = "github_token")]
    pub github_token: Option<String>,

    // TODO: Rename to clone_url.
    /// The HTTPS git URL for the repository.
    #[serde(rename = "gitHubUrl")]
    pub github_url: String,
}

impl PilotContext {
    pub fn validate(&self) -> Result<(), Error> {
        let mut errors: String = String::from("");

        if self.team_id.is_empty() {
            errors.push_str("teamId required\n");
        }

        if self.project_id.is_empty() {
            errors.push_str("projectId required\n");
        }

        if self.codebase_id.is_empty() {
            errors.push_str("codebaseId required\n");
        }

        if self.cloud_front_domain.is_empty() {
            errors.push_str("cloudFrontDomain required\n");
        }

        if self.token.is_empty() {
            errors.push_str("harborToken required\n");
        }

        if self.github_url.is_empty() {
            errors.push_str("gitHubUrl required\n");
        }

        if !errors.is_empty() {
            return Err(Error::Pilot(format!("Invalid request parameters: {}", errors)));
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct PilotService {}

impl PilotService {
    #[instrument]
    pub async fn clone_syft_upload(&self, ctx: PilotContext) -> Result<SBOMUploadResponse, Error> {
        ctx.validate()?;
        let clone_path = clone_path(&ctx.github_url);

        clone_repo(&clone_path, &ctx.github_url)?;

        let syft_result = syft(&clone_path)?;

        remove_clone(&clone_path)?;

        self.upload_sbom(
            ctx.cloud_front_domain.as_str(),
            ctx.token.as_str(),
            ctx.team_id,
            ctx.project_id,
            ctx.codebase_id,
            syft_result,
        )
            .await
    }

    /// TODO: This creates an HTTP dependency.  Think about the right solution.
    /// Uploads an SBOM to the Enrichment Engine.
    #[instrument]
    pub async fn upload_sbom(&self,
        cloud_front_domain: &str,
        sbom_token: &str,
        team_id: String,
        project_id: String,
        codebase_id: String,
        sbom: HashMap<String, Value>,
    ) -> Result<SBOMUploadResponse, Error> {

        let url = self.create_upload_url(cloud_front_domain, team_id, project_id, codebase_id);

        let response: Option<SBOMUploadResponse> =
            post(url.as_str(), ContentType::Json, sbom_token, Some(sbom)).await?;

        Ok(response.unwrap())
    }

    fn create_upload_url(&self,
        cloud_front_domain: &str,
        team_id: String,
        project_id: String,
        codebase_id: String,
    ) -> String {
        join_url(
            cloud_front_domain,
            &format!("/api/v1/{}/{}/{}/sbom", team_id, project_id, codebase_id),
        )
    }
}

/// TODO: Move all of this to a Provider interface.
/// Invokes the syft CLI against the cloned repository to generate an SBOM.
pub fn syft(source_path: &str) -> Result<HashMap<String, Value>, Error> {
    let output = match Command::new("syft")
        .arg("--output")
        .arg(CYCLONEDX_JSON_FORMAT)
        .arg(source_path)
        .output()
    {
        Ok(output) => output,
        Err(err) => {
            return Err(Error::Syft(format!("error executing syft cli: {}", err)));
        }
    };

    // Handle error generated by syft.
    if !&output.status.success() {
        return match String::from_utf8(output.stderr) {
            Ok(stderr) => {
                Err(Error::Syft(format!("error generating SBOM: {}", &stderr)))
            }
            Err(err) => {
                Err(Error::Syft(format!("error formatting syft stderr: {}", &err)))
            }
        };
    }

    if output.stdout.is_empty() {
        return Err(Error::Syft("syft generated empty SBOM".to_string()));
    };

    match serde_json::from_slice::<HashMap<String, Value>>(output.stdout.as_slice()) {
        Ok(result) => Ok(result),
        Err(err) => {
            return Err(Error::Serde(format!("error serializing SBOM to hash map: {}", err)));
        }
    }
}

/// Clones a git repository to the specified clone path.
pub fn clone_repo(clone_path: &str, url: &str) -> Result<(), Error> {
    info!("Cloning repo: {}", url);

    match Repository::clone(url, clone_path) {
        Err(err) => {
            return Err(Error::Git(format!("error cloning repository from {}: {}", url, err)));
        }
        _ => info!("Successfully cloned repo"),
    };

    Ok(())
}

/// Generates a unique clone path for a repository.
pub fn clone_path(url: &str) -> String {
    // add a unique element to the path to prevent collisions.
    let timestamp = Utc::now().to_rfc3339();

    let repo_name = url
        .split('/')
        .collect::<Vec<&str>>()
        .pop()
        .unwrap()
        .replace(".git", "");

    format!("/tmp/{}/{}", timestamp, repo_name)
}

/// Removes a cloned repository from the filesystem.
pub fn remove_clone(clone_path: &str) -> Result<(), Error> {
    if Path::new(&clone_path).is_dir() {
        return std::fs::remove_dir_all(clone_path)
            .map_err(|e| Error::Io(e.to_string()));
    }

    Ok(())
}

/// Metadata returned by the Enrichment Engine indicating the status of the upload request.
#[derive(Debug, Deserialize, Serialize)]
pub struct SBOMUploadResponse {
    /// Flag indicating whether the request was considered valid.
    pub valid: bool,
    /// The S3 bucket name the SBOM was uploaded to.
    #[serde(rename = "s3BucketName")]
    pub bucket_name: String,
    /// The S3 object key for the uploaded SBOM.
    #[serde(rename = "s3ObjectKey")]
    pub object_key: String,
}

impl Display for SBOMUploadResponse {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
        write!(
            f,
            "valid: {}, bucket_name: {}, object_key: {}",
            self.valid, self.bucket_name, self.object_key
        )
    }
}
