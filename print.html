<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Harbor</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview/what-is-an-sbom.html"><strong aria-hidden="true">1.</strong> What is an SBOM?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/how-are-sboms-useful.html"><strong aria-hidden="true">1.1.</strong> How are SBOMs useful?</a></li><li class="chapter-item expanded "><a href="overview/how-does-harbor-fit-in.html"><strong aria-hidden="true">1.2.</strong> How does Harbor fit in?</a></li><li class="chapter-item expanded "><a href="overview/how-does-harbor-work.html"><strong aria-hidden="true">1.3.</strong> How does Harbor work?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/ingestion.html"><strong aria-hidden="true">1.3.1.</strong> Ingestion</a></li><li class="chapter-item expanded "><a href="overview/enrichment.html"><strong aria-hidden="true">1.3.2.</strong> Enrichment</a></li><li class="chapter-item expanded "><a href="overview/continuous-monitoring.html"><strong aria-hidden="true">1.3.3.</strong> Continuous Monitoring</a></li><li class="chapter-item expanded "><a href="overview/continuous-enrichment.html"><strong aria-hidden="true">1.3.4.</strong> Continuous Enrichment</a></li></ol></li><li class="chapter-item expanded "><a href="overview/harbor-user-interface.html"><strong aria-hidden="true">1.4.</strong> Does Harbor have UI?</a></li></ol></li><li class="chapter-item expanded "><a href="use-cases/overview.html"><strong aria-hidden="true">2.</strong> Use Cases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-cases/vendor-management.html"><strong aria-hidden="true">2.1.</strong> Vendor Management</a></li><li class="chapter-item expanded "><a href="use-cases/custom-development.html"><strong aria-hidden="true">2.2.</strong> Custom Development</a></li></ol></li><li class="chapter-item expanded "><a href="data-model/overview.html"><strong aria-hidden="true">3.</strong> Data Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-model/sboms.html"><strong aria-hidden="true">3.1.</strong> SBOMs</a></li><li class="chapter-item expanded "><a href="data-model/packages.html"><strong aria-hidden="true">3.2.</strong> Packages</a></li><li class="chapter-item expanded "><a href="data-model/vulnerabilities.html"><strong aria-hidden="true">3.3.</strong> Vulnerabilities</a></li><li class="chapter-item expanded "><a href="data-model/tasks.html"><strong aria-hidden="true">3.4.</strong> Tasks</a></li><li class="chapter-item expanded "><a href="data-model/organizations.html"><strong aria-hidden="true">3.5.</strong> Organizations</a></li><li class="chapter-item expanded "><a href="data-model/xrefs.html"><strong aria-hidden="true">3.6.</strong> Xrefs</a></li></ol></li><li class="chapter-item expanded "><a href="deployment/overview.html"><strong aria-hidden="true">4.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="SDK/overview.html"><strong aria-hidden="true">5.</strong> SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SDK/platform/overview.html"><strong aria-hidden="true">5.1.</strong> Platform</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SDK/platform/mongodb/overview.html"><strong aria-hidden="true">5.1.1.</strong> MongoDB</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SDK/platform/mongodb/store.html"><strong aria-hidden="true">5.1.1.1.</strong> Store</a></li><li class="chapter-item expanded "><a href="SDK/platform/mongodb/service.html"><strong aria-hidden="true">5.1.1.2.</strong> Service</a></li><li class="chapter-item expanded "><a href="SDK/platform/mongodb/migrations.html"><strong aria-hidden="true">5.1.1.3.</strong> Migrations</a></li></ol></li><li class="chapter-item expanded "><a href="SDK/platform/authz.html"><strong aria-hidden="true">5.1.2.</strong> Authz</a></li></ol></li><li class="chapter-item expanded "><a href="SDK/core/overview.html"><strong aria-hidden="true">5.2.</strong> Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SDK/core/entities.html"><strong aria-hidden="true">5.2.1.</strong> Entities</a></li><li class="chapter-item expanded "><a href="SDK/core/services.html"><strong aria-hidden="true">5.2.2.</strong> Services</a></li><li class="chapter-item expanded "><a href="SDK/core/providers.html"><strong aria-hidden="true">5.2.3.</strong> Providers</a></li><li class="chapter-item expanded "><a href="SDK/core/tasks.html"><strong aria-hidden="true">5.2.4.</strong> Tasks</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="road-map.html"><strong aria-hidden="true">6.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="contributing/overview.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/design-guidelines.html"><strong aria-hidden="true">7.1.</strong> Design Guidelines</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Harbor</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Harbor is a system for:</p>
<ul>
<li>Collecting, categorizing, and storing SBOMs. The process of collecting SBOMs is called 
<strong><em>ingestion</em></strong>.</li>
<li>Analyzing SBOMs to identify associated vulnerability and supply chain data. The process of 
identifying and storing vulnerability and supply chain data associated with SBOMs is called 
<strong><em>enrichment</em></strong>.</li>
</ul>
<h3 id="compliance"><a class="header" href="#compliance">Compliance</a></h3>
<p>Harbor was born out of the <a href="https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/">Cyber Executive Order</a>
which mandates that all federal agencies must procure and catalog SBOMs for all software they 
purchase or develop. Compliance with the Executive Order is achieved through the <strong><em>ingestion</em></strong> 
and storage of SBOMs.</p>
<h3 id="operational-security"><a class="header" href="#operational-security">Operational Security</a></h3>
<p>While <strong><em>ingestion</em></strong> and <strong>storage</strong> (I&amp;S) are mandatory first steps, those activities alone do 
nothing to secure an organization's software supply chain. The Executive Order implies that in 
addition to collecting and storing SBOMs, they should be analyzed, and the resulting threat 
intelligence be leveraged by operators responsible for securing systems. Harbor provides 
operators built-in <strong><em>enrichment</em></strong> providers that generate actionable risk intelligence derived 
from both free and commercial sources. The community is welcome to use the built-in providers or 
contribute additional implementations.</p>
<h3 id="inter-organization-collaboration"><a class="header" href="#inter-organization-collaboration">Inter-Organization Collaboration</a></h3>
<p>Harbor is being developed by CMS as an open source project so that it can be used by any 
organization, public or private, to improve their software supply chain security posture and to
comply with the Executive Order.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-an-sbom"><a class="header" href="#what-is-an-sbom">What is an SBOM?</a></h2>
<p>SBOM is an acronym that stands for <em>Software Bill of Materials</em>. One way to think of an SBOM is 
as a parts list for your car. A car isn't naturally a car. It's a combination of components such as 
the wheels, chassis, steering-wheel, airbags, etc.</p>
<p>Similarly, in this day and age, most if not all software uses external, often open source, 
components written by other, usually unrelated people, teams or companies. So, similar to how a 
car is made up of components, a piece of software, or a <code>Package</code> in Harbor terminology, is made 
up of other components, and just like a car, a component, might have subcomponents.</p>
<p>When one software component depends on another we typically refer that relationship as a <code>Dependency</code>.
Both components are ultimately a <code>Package</code>, but Harbor uses the terms <code>Primary</code> and <code>Dependency</code> 
to provides context about the relationship between two <code>Packages</code>.</p>
<p>Taking all that into context, we can update our definition of an SBOM to the following:</p>
<blockquote>
<p>An SBOM is a machine-readable document that:</p>
<ul>
<li>Describes a software package</li>
<li>Provides a unique identifier for the package, similar to a part number in manufacturing</li>
<li>Provides information about the supplier</li>
<li>Lists the dependencies that make up the package</li>
</ul>
</blockquote>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>That expanded definition includes the requirement that an SBOM be defined in a machine-readable 
format. At this time, there are two dominant SBOM specifications for the format of an SBOM which 
are:</p>
<ul>
<li><a href="https://cyclonedx.org/">CycloneDX</a> backed by the <a href="https://owasp.org/">OWASP Foundation</a>.</li>
<li><a href="https://spdx.dev/">SPDX</a> backed by the <a href="https://www.linuxfoundation.org/">Linux Foundation</a>.</li>
</ul>
<p>At this time, Harbor is focused on processing files in the CycloneDX format. This is not an 
endorsement of one specification over the other, as much as a pragmatic decision based on 
availability of data. We do have SPDX support in our backlog, and ultimately intend to support 
both formats. Community PRs welcome!</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Here is an example of a very minimal SBOM in CycloneDX JSON format.</p>
<pre><code class="language-json">{
    &quot;$schema&quot;: &quot;http://cyclonedx.org/schema/bom-1.4.schema.json&quot;,
    &quot;bomFormat&quot;: &quot;CycloneDX&quot;,
    &quot;specVersion&quot;: &quot;1.4&quot;,
    &quot;version&quot;: 1,
    &quot;metadata&quot;: {
        &quot;timestamp&quot;: &quot;2023-06-06T11:29:16Z&quot;,
        &quot;component&quot;: {
            &quot;bom-ref&quot;: &quot;example-app@1.2.3&quot;,
            &quot;type&quot;: &quot;application&quot;,
            &quot;name&quot;: &quot;project&quot;,
            &quot;purl&quot;: &quot;pkg:nuget/exampl-app@1.2.3&quot;
        }
    },
    &quot;components&quot;: [
        {
            &quot;bom-ref&quot;: &quot;example-library@2.3.4&quot;,
            &quot;type&quot;: &quot;library&quot;,
            &quot;name&quot;: &quot;stateless-4.0&quot;,
            &quot;version&quot;: &quot;2.3.1.1&quot;,
            &quot;purl&quot;: &quot;pkg:nuget/example-library@2.3.4&quot;
        }
    ],
    &quot;dependencies&quot;: [
        {
            &quot;ref&quot;: &quot;example-app@1.2.3&quot;,
            &quot;dependsOn&quot;: [
                &quot;example-library@2.3.4&quot;
            ]
        },
        {
            &quot;ref&quot;: &quot;example-library@2.3.4&quot;,
            &quot;dependsOn&quot;: []
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-are-sboms-useful"><a class="header" href="#how-are-sboms-useful">How are SBOMs useful?</a></h2>
<p>Sticking with the car analogy, let us consider what happens when a component manufacturer determines 
that there was a defect in a specific batch of airbags they produced? Typically, they issue a recall.
Once the recall is issued, the dealer is notified, and then you, the consumer receive a letter from 
the dealer telling you bring your car in and have your airbag replaced. This whole system works 
because the manufacturer and dealer are required by regulation to participate in a data-sharing 
relationship.</p>
<p>So if car parts are like software packages, wouldn't it be great if there were some sort of data-sharing 
relationship that software producers and consumers could participate in? It turns out there is! 
It's called <a href="https://nvd.nist.gov/">National Vulnerability Database</a> or <code>NVD</code>, and it's 
maintained by the <a href="https://www.nist.gov/">National Institute of Standards and Technology</a> (NIST).
Security researchers from across both industry and academia submit their findings to the <code>NVD</code> 
and updates are published weekly.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-does-harbor-fit-in"><a class="header" href="#how-does-harbor-fit-in">How does Harbor fit in?</a></h2>
<p>Unlike automobile manufacturing, software development. maintenance, and procurement is happening in 
virtually every organization in the industrialized world. The identity and operations locales of the
world's automobile manufacturers and parts suppliers is arguably knowable and can be regulated. </p>
<p>Conversely, the number of software systems, developers, consumers, and operators on the planet is a 
far more challenging catalog to develop and maintain. Even if you could identify all the developers 
and consumers, the age of cloud computing has made it so that the systems themselves are ephemeral 
and can come and go many times a day if not minute. This ultimately means that organizations that 
operate software systems will need to actively maintain an inventory of their own systems and actively 
opt-in to a vulnerability data-sharing relationship. </p>
<p><strong>Harbor</strong> is a system designed to empower you as a system operator to create and maintain an 
inventory of software components relative to your operations. Once you have established your inventory, 
you can hook into the different sources of vulnerability data, or enrichment sources, and manage 
your own <em>recall</em> process when you determine a vulnerability is relevant to your organization.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-does-harbor-work"><a class="header" href="#how-does-harbor-work">How does Harbor work?</a></h2>
<p>An SBOM is just a file that is guaranteed to conform to a specification that is designed for
machine-readability. As long as the file conforms to the specification, Harbor can parse it once it
is received, and identify its dependencies. The primary feature of an SBOM is to provide the 
list of components that a software package depends on. Harbor either collects or accepts an SBOM and
then analyzes it.</p>
<p>Once, the dependencies are identified they can be cross-referenced with the different enrichment 
sources to identify known vulnerabilities and ideally infer some sort of risk score for the issue.
Many times the enrichment sources can even provide remediation advice.</p>
<h3 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h3>
<p>Specifically, the lifecycle of an SBOM within Harbor consists of four phases:</p>
<ul>
<li>Ingestion</li>
<li>Enrichment</li>
<li>Continuous Monitoring</li>
<li>Continuous Enrichment</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ingestion"><a class="header" href="#ingestion">Ingestion</a></h2>
<p>The <em>ingestion</em> phase is the phase during which Harbor receives an SBOM for a software package
being monitored. SBOMs can be <em>ingested</em> in one of three ways:</p>
<ul>
<li>Syncing with an external SBOM provider (see <code>cli/src/commands/sbom</code> and
<code>sdk/core/src/services/sboms/snyk</code>).</li>
<li>Manual upload through the UI.</li>
<li>Automated upload via the API.</li>
</ul>
<p>During the <em>ingestion</em> phase, SBOMs are parsed, analyzed, and then mapped to the Harbor data model.
Once that process is complete the raw SBOM is then stored. In order to maintain the integrity of the
system relative to the tampering concern, SBOMs should be treated as <strong>immutable</strong> once stored. The
CMS Harbor instance stores SBOMs in Amazon S3 and leverages features of that platform to ensure
immutability. Organizations that wish to run a Harbor instance need to be aware of this concern and
develop a tamper-resistance storage strategy appropriate for their environment.</p>
<blockquote>
<p>By convention, the Harbor team implements tasks as CLI commands that can be run via an 
orchestrator. In our case, we deploy Fargate tasks that can be parameterized and invoked.
Organizations are free to leverage the business logic found in <code>sdk/core/src/services</code> using 
whatever scheduling mechanism is appropriate for their operating environment.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enrichment"><a class="header" href="#enrichment">Enrichment</a></h2>
<p>Enrichment is the process by which additional metadata about SBOMs is generated and stored.
Examples of <em>enrichment</em> data include:</p>
<ul>
<li>Vulnerabilities associated with a package or its dependencies.</li>
<li>Scores related to vulnerabilities (e.g. EPSS, CVSS) for a package or its dependencies.</li>
<li>Quality metrics about the SBOM itself (e.g. <a href="https://github.com/eBay/sbom-scorecard">sbom-scorecard</a> results).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="continuous-monitoring"><a class="header" href="#continuous-monitoring">Continuous Monitoring</a></h2>
<p>SBOMs can change over time. In a perfect world, an SBOM for a given tag/version of a component
will never change. In reality, teams don't always conform and treat a release tag as immutable.
Sometimes, a problematic release is deleted and replaced with an update that reuses the version
number. This could happen with code in a repository being directly monitored or in a dependency.</p>
<p>Additionally, sometimes what you want to monitor is one or more branches of a code repository
rather than a release tag. This is useful in CI/CD situation where you want to get an early signal
that a vulnerable dependency is being added, or when a new vulnerability emerges for an existing
dependency.</p>
<p>To support these use cases, the CLI <code>sbom</code> command can be run on a schedule to get an up to date
SBOM for each code repository being monitored. We call this batch sync process <strong>continuous monitoring</strong>.
Follow the code path starting in <code>cli/commands/sbom</code> for an example of how to implement a 
continuous monitoring provider.</p>
<blockquote>
<p>The CMS Harbor team uses <a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/fargate-task-defs.html">Fargate Tasks</a>
to schedule and run cli commands at predictable intervals based on organizational policies.
Organizations that wish to run a Harbor instance will need to determine the appropriate
synchronization strategy and tooling for their environment.</p>
</blockquote>
<blockquote>
<p>From a file storage perspective, operators should be aware that SBOM file names are not 
guaranteed to be unique at this time. As previously mentioned, the CMS Harbor team leverages S3 for 
file storage and versioning. Harbor itself ships with a file system storage provider that we use 
primarily for local development. It should be possible to use this provider to leverage attached 
storage in a production system, though we haven't fully explored this use case. You may need to 
modify the source and submit a PR if the current implementation doesn't fully support this approach.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="continuous-enrichment"><a class="header" href="#continuous-enrichment">Continuous Enrichment</a></h2>
<p>Vulnerabilities emerge non-deterministically over time. A dependency that did not have any known
vulnerabilities yesterday may have one or more today. Similarly, EPSS and CVSS scores may change
over time.</p>
<p>To ensure that the latest enrichment data is available, the CLI <code>enrich</code> command can be run
idempotently at scheduled intervals. We call this batch scan process <strong>continuous enrichment</strong>.
Follow the code path in <code>cli/commands/enrich</code> for examples of how to implement a continuous
enrichment provider.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="does-harbor-have-a-user-interface"><a class="header" href="#does-harbor-have-a-user-interface">Does Harbor have a User Interface?</a></h2>
<p>Yes!</p>
<p>The Harbor UI is maintained in a separate repository which can be found <a href="https://github.com/CMS-Enterprise/sbom-harbor-ui">here</a>. 
All contributing guidelines documented here are applicable for that repository as well, and pull 
requests are welcome!</p>
<p><img src="overview/harbor-ui.png" alt="Harbor User Interface" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>At this time, Harbor is targeting two primary use cases:</p>
<ul>
<li>Ingesting and managing SBOMs provided by SaaS/COTS vendors</li>
<li>SBOMs related to custom software development initiatives</li>
</ul>
<h3 id="current-state"><a class="header" href="#current-state">Current State</a></h3>
<p>After some early experimentation and discovery relative to the CMS operating environment, we
determined that the fastest way to create a pipeline that facilitated building out multiple facets
of the system was to focus on Snyk as both an SBOM and enrichment provider. Snyk has been widely 
adopted across development teams at CMS. Once a team has been onboarded to Snyk, it can operate as 
both an SBOM provider and a source of vulnerability data.</p>
<h3 id="future-state"><a class="header" href="#future-state">Future State</a></h3>
<p>This isn't the end of the story, however. Not all development teams at CMS use Snyk. Additionally, 
since Harbor is being built specifically with the goal of being usable by any agency or organization, 
there is no guarantee that the Snyk integration is an option. Therefore, other SBOM providers 
(e.g. GitHub) and enrichment sources are being developed. Contributors are encouraged to submit PRs
for any custom providers they write and wish to contribute to the community.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vendor-management"><a class="header" href="#vendor-management">Vendor Management</a></h2>
<p>While vendors of SaaS and COTS products are expected to generate their own SBOMs, organizations
affected by the Executive Order are still required to collect and store SBOMS they receive from 
vendors. Harbor provides a way to <em>ingest</em>, <em>enrich</em>, and <em>track</em> vendor supplied SBOMs over time. 
Our current development relative to vendor supplied SBOMs is focused on enabling users within an 
organization that receives SBOMs from vendors to upload them via a user interface. User research is 
underway with vendors to determine what if any automated upload mechanism they would prefer to use.</p>
<p>The scope of the vendor-provided SBOM management feature of Harbor is limited at this time. It may
expand as the research continues, but as of now, the MVP as defined in the roadmap section is 
what is being targeted.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="custom-development"><a class="header" href="#custom-development">Custom Development</a></h2>
<p>The majority of systems at CMS that require SBOM cataloging and monitoring are custom
development projects. Given that, Harbor's roadmap is largely concerned with automatically
generating and ingesting SBOMs for these projects. Once ingested, the enrichment engine operates
on all SBOMs the same regardless of whether a vendor or a development team was the source.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="data-model"><a class="header" href="#data-model">Data Model</a></h2>
<p>The following diagram provides an integrated overview of the Harbor data model. Data model types
can be found in the <code>sdk/core/src/entities</code> subdirectory and are further segregated by subdomain.
The diagram below shows a high level overview of the entities and their relationships. See 
entity specific pages for diagrams and explanations of each subdomain.</p>
<p><img src="data-model/overview.png" alt="Overview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sboms"><a class="header" href="#sboms">SBOMs</a></h2>
<p>The <code>Sbom</code> entity records that an SBOM was ingested or generated for a <code>Package</code> that is being
<em>directly monitored</em>. See the <a href="data-model/./packages.html"><code>Packages</code></a> documentation for a 
discussion.</p>
<p><img src="data-model/sboms.png" alt="SBOMs" /></p>
<h3 id="data-dictionary"><a class="header" href="#data-dictionary">Data Dictionary</a></h3>
<ul>
<li><code>Sbom</code> - An SBOM is a snapshot manifest of the components that make up a piece of software at a 
moment in time.</li>
<li><code>Package</code> - An inventory item from an <code>Sbom</code>. Can be defined by standard identifiers like CPE 
or PURL.</li>
<li><code>Vulnerability</code> - An identified security vulnerability related to a <code>Package</code>.</li>
<li><code>Author</code> - The actor that provided or generated the Sbom. For vendor supplied SBOMS, this 
will be the vendor name. For SBOMs generated via automation, this will be the name of the SBOM 
provider that was used to generate the SBOM (e.g. Snyk, Syft).</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p><img src="data-model/packages.png" alt="Packages" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vulnerabilities"><a class="header" href="#vulnerabilities">Vulnerabilities</a></h2>
<p><img src="data-model/vulnerabilities.png" alt="Vulnerabilities" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p><img src="data-model/tasks.png" alt="Tasks" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="organizations"><a class="header" href="#organizations">Organizations</a></h2>
<p><img src="data-model/organizations.png" alt="Organizations" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="xrefs"><a class="header" href="#xrefs">Xrefs</a></h2>
<p><img src="data-model/xrefs.png" alt="Xrefs" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>All the current features revolve around:</p>
<p>Ingestion</p>
<ul>
<li>Collecting and storing SBOM files</li>
<li>Analyzing SBOM contents</li>
<li>Translating analysis results to the Harbor data model</li>
<li>Persisting results to a MongoDB-compliant data store</li>
</ul>
<p>Enrichment</p>
<ul>
<li>Collecting and storing vulnerability data related to SBOMs</li>
<li>Collecting and storing metadata about vulnerabilities</li>
<li>Collecting and storing quality metrics related to SBOM contents</li>
</ul>
<p>Analytics</p>
<ul>
<li>Providing programmatic access to the analysis results</li>
</ul>
<p>To support these use cases, we have designed Harbor with the fundamental expectation that a typical 
instance is made up of the following resources:</p>
<ul>
<li>MongoDB instance</li>
<li>File/Object storage</li>
<li>API</li>
<li>Task Orchestrator</li>
</ul>
<p><img src="deployment/deployment.png" alt="Deployment Diagram" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>The Harbor SDK is currently comprised of a docker-compose based development environment, the
<code>platform</code> and <code>core</code> crates, an OpenAPI specification, a custom extension template, and code 
generators. Details of the <code>platform</code> and <code>core</code> crates can be found in their respective 
subsections, but an overview of the other SDK resources is included below.</p>
<h3 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h3>
<p>A fully functional development environment can be found in the <code>devenv</code> directory. To run the 
environment, run <code>docker compose up</code> from that directory.</p>
<h3 id="custom-extension-template"><a class="header" href="#custom-extension-template">Custom Extension Template</a></h3>
<p>Operating environments will differ by organization. Harbor cannot anticipate every SBOM ingestion or
enrichment source or use case. Likewise, it cannot define a data model that meets the needs of every
imaginable scenario or is compatible with all existing and emerging SBOM specifications. What it can
and does do is define a core domain model related to the ingestion, storage, enrichment, and analysis
of SBOMs, and exposes mechanisms of extension.</p>
<p>The <code>TaskProvider</code> trait found in the <code>core</code> crate is specifically designed to enable 
extensibility from the beginning. If the massive success of <a href="https://www.hashicorp.com/">HashiCorp</a>
<a href="https://www.terraform.io/">Terraform</a> is any indicator, the engineering community prefers 
solutions they can extend and customize. Terraform adopts a <a href="https://developer.hashicorp.com/terraform/language/providers">Provider</a>
model for enabling plugins. This is conceptually, is how we envision building and extending the 
upstream Harbor feature set. Contributions to upstream Harbor must conform to this model to be
considered. </p>
<p>Community members that need to build solutions specific to their operating environment or use 
case(s) can use the <code>extension-template</code> example project found in the <code>sdk</code> directory to create 
a custom CLI that can be invoked by their task orchestrator. It includes an example of how to
leverage functionality exposed by the <code>core</code> crate in your custom Rust code. </p>
<p>Organizations that cannot or do not want to write custom providers in Rust can leverage the OpenAPI
specification to write providers in other languages.</p>
<h3 id="openapi"><a class="header" href="#openapi">OpenAPI</a></h3>
<p>The <code>sdk/openapi</code> directory contains an <a href="https://www.openapis.org/">OpenAPI Specification</a> for 
Harbor. It also contains scripts and config that we use to generate our <a href="https://github.com/CMS-Enterprise/sbom-harbor-ui">UI</a>
client as well as some tests for the <code>api</code>. The scripts use the <a href="https://openapi-generator.tech/">OpenAPI Generator</a>
tool and may be useful as a model for organizations that need or want to generate a client for the 
Harbor API.</p>
<h3 id="generators"><a class="header" href="#generators">Generators</a></h3>
<p>The <code>sdk/generators</code> directory includes some simple code generation tooling built using 
<a href="https://cargo-generate.github.io/cargo-generate/"><code>cargo generate</code></a>. The generators can be 
used to generate scaffolding for api endpoints, new cli commands, and task providers. The 
generators are not designed to provide complete, robust implementations as much as opinionated 
guidance and awareness relative to project structure and conventions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="platform-crate"><a class="header" href="#platform-crate">Platform Crate</a></h2>
<p>The <code>platform</code> crate contains reusable functionality related to completely generic programming
tasks that are not and should not be coupled to the Harbor domain. Externalizing these features to
their own crate is designed to help promote code reuse, simplify dependency management, provide
consistent implementations of common functions, and enforce a strict separation of concerns.</p>
<p>Code in this crate typically falls into one of three categories:</p>
<ul>
<li>features that can be mentally modeled as extensions to the Rust standard library</li>
<li>features that reduce boilerplate</li>
<li>features that encapsulate infrastructure resources like databases, storage systems, and networks.</li>
</ul>
<p>Examples of the types code that should belong in this crate include:</p>
<ul>
<li>Cryptography</li>
<li>Encoding</li>
<li>Networking</li>
<li>Database access &amp; migrations</li>
<li>Authorization/Authentication</li>
</ul>
<blockquote>
<h3 id="a-note-on-cargo-features"><a class="header" href="#a-note-on-cargo-features">A Note on Cargo Features</a></h3>
<p>Harbor does not currently implement <a href="https://doc.rust-lang.org/cargo/reference/features.html"><code>cargo</code> features</a>,
but has been designed in a way that should allow introducing them with minimal refactoring. 
Keeping this in mind when developing, especially when working with the <code>platform</code> crate is an 
effective mental discipline that can help in designing modules that enforce a strict separation
of concerns.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mongodb"><a class="header" href="#mongodb">MongoDB</a></h2>
<p>The MongoDB module is an opinionated micro-framework for interacting with the MongoDB backend that 
Harbor currently supports. This module was developed based on the following needs and desires:</p>
<ul>
<li>At the time of initial development there did not seem to be a widely-used or well-maintained 
Rust-based Object Document Mapper (ODM) available from the ecosystem. Database mapping code is 
inherently full of boilerplate, which we equate to engineering toil, and can also be a 
significant source of bugs. While the Rust type system helps with the latter issue to a great 
degree, we still wanted to leverage generics to generate as much boilerplate code as possible.</li>
<li>The official Mongo Rust Driver (see below) is a low-level driver designed to allow total control of 
all aspects of MongoDB interaction. We wanted a way to abstract away that complexity and allow 
developers to focus on domain logic rather than repeatedly handle infrastructure concerns.</li>
<li>We wanted database interactions to be consistent and easily refactorable in a handful of places 
rather than scattered throughout the codebase.</li>
<li>We needed a way to apply DB Migrations over time.</li>
<li>We needed a way to dynamically and unpredictably layer in Authz controls. In order to do that 
we needed to keep authorization concerns/data separate from the entity data itself. Building a 
micro-framework gave us significant control and flexibility in this regard.</li>
</ul>
<h3 id="design"><a class="header" href="#design">Design</a></h3>
<p>The basic interaction between the types and traits involved in data access are illustrated below.
The diagram documents an update sequence.</p>
<p><img src="SDK/platform/mongodb/mongodb-overview-sequence.png" alt="MongoDB-overview-sequence" /></p>
<h3 id="documentdb-compatability"><a class="header" href="#documentdb-compatability">DocumentDB Compatability</a></h3>
<p>The Harbor team actually uses AWS DocumentDB as its data store. DocumentDB has some lag in terms of
MongoDB version support and feature compatability. Review the <a href="https://docs.aws.amazon.com/documentdb/latest/developerguide/compatibility.html">AWS DocumentDB compatability</a>
page for an overview of what versions and features Harbor can support.</p>
<h3 id="mongo-rust-driver"><a class="header" href="#mongo-rust-driver">Mongo Rust Driver</a></h3>
<p>Harbor leverages <a href="https://github.com/mongodb/mongo-rust-driver">the official MongoDB Rust Driver</a>. 
Review their documentation for a comprehensive overview of how the driver works and how to work 
with the driver.</p>
<p>One important design consideration to bring attention to is managing instances of the driver 
<code>Client.</code> The Mongo Rust Driver is designed in a very specific way in terms of <a href="https://mongodb.github.io/mongo-rust-driver/manual/performance.html">connection 
management</a>.
Connections are designed to be long-lived. We learned the hard way that they require a
significant amount of overhead to create, especially when negotiating TLS. The 
<code>platform:mongodb::Store</code> struct provides a convention-based way to ensure reuse of Mongo client 
instances when possible and appropriate, which so far has been always. Code that makes use of a 
<code>Store</code> should wrap that in an <code>Arc</code> and reuse a single instance.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="store"><a class="header" href="#store">Store</a></h2>
<p>The <code>Store</code> is a facade that provides a coarsely-grained way to perform common operations 
against a MongoDB compliant data store. The <code>Store</code> is designed to work generically against any 
type that implements the <code>MongoDocument</code> trait. Harbor application code should typically not 
reference a<code>Store</code> directly, but instead should call a type that implements the <code>Service</code> trait.</p>
<p>The <code>Store</code> is the type that wraps the long-lived MongoDB client. Because of that, the <code>Store</code> 
should also be long-lived. You should wrap the <code>Store</code> in an <code>Arc</code> and clone the <code>Arc</code> whenever 
you need to access the <code>Store</code>. There are numerous examples that can be referenced already in 
the codebase.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="service"><a class="header" href="#service">Service</a></h2>
<p>The <code>mongodb::Service</code> trait provides consistent, generic persistence capabilities for types that 
implement the<code>MongoDocument</code> trait. It is specialized to the opinionated conventions adopted by the 
Harbor Team. It can be thought of as a pre-and-post-processor that ensures mandatory generic logic 
is consistently applied across all operations against a <code>Store</code>. Application code should not need 
to be aware of the <code>Store</code> and should perform operations against a <code>Service</code> instead.</p>
<h3 id="mongodocument-trait"><a class="header" href="#mongodocument-trait">MongoDocument Trait</a></h3>
<p>The <code>MongoDocument</code> trait must be applied to any entities you wish to persist to MongoDB as the 
root document of a collection. The trait provides two capabilities. First, it provides the 
<code>Store</code> a way to retrieve the type name of a passed struct dynamically at run time. The type 
name is used to resolve the collection the struct belongs to. Second, since Rust traits cannot 
contain fields, the trait provides default getter and setter functions for the <code>id</code> field. This 
is required, because the <code>Service</code> trait is designed around the convention that all entity keys 
are uniformly named.</p>
<p>This implies two things:</p>
<ul>
<li>Harbor's MongoDB collections will be named after the struct they contain.</li>
<li>Entities must have a public <code>id</code> field of type <code>String</code>.</li>
</ul>
<p>The <code>MongoDocument</code> trait can be applied to any conformant entity by applying the <code>mongo_doc</code> macro 
as show here.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use platform::persistence::mongodb::mongo_doc;

mongo_doc!(Package);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>Sometimes, it is necessary to refactor a data model after it has already been released to 
production. The <code>migrations</code> module provides a mechanism to either <code>apply</code> and <code>rollback</code> a 
migration. This mechanism is limited in its opinions and feature set, since migrations are highly 
contextual by their nature. Migration script authors are responsible for ensuring that their 
migrations are either idempotent and safe to re-run, or for checking the migration log to 
determine if a script has already been applied.</p>
<h3 id="migration-component-model"><a class="header" href="#migration-component-model">Migration Component Model</a></h3>
<p>A migration script can be defined by implement the <code>Migration</code> trait which specifies the following 
interface.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Migration {
    /// The human readable name of the migration.
    fn name(&amp;self) -&gt; String;
    /// The set of operations to apply to a database to migrate it to a desired new state.
    async fn commit(&amp;self, service: &amp;MigrationService) -&gt; Result&lt;LogEntry, Error&gt;;
    /// The set of operations to undo a previously committed migration.
    async fn rollback(&amp;self, service: &amp;MigrationService) -&gt; Result&lt;LogEntry, Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>Migration</code> implementation can then be passed to the <code>MigrationService</code> along with an <code>Effect</code> 
enum. The <code>Effect</code> enum specifies whether to apply or rollback the migration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MigrationService {
    /// Factory method for creating a new `MigrationService` instance.
    pub async fn new(ctx: &amp;Context) -&gt; Result&lt;MigrationService, Error&gt; {
        Ok(MigrationService { ctx: ctx.clone() })
    }

    /// Applies a migration with the specified effect.
    pub async fn apply(
        &amp;self,
        migration: &amp;impl Migration,
        effect: Effect,
    ) -&gt; Result&lt;LogEntry, Error&gt; {
        match effect {
            Effect::Commit =&gt; migration.commit(self).await,
            Effect::Rollback =&gt; migration.rollback(self).await,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>User code is required to coordinate the application of migrations, in which order, and to what 
effect.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="authz"><a class="header" href="#authz">AuthZ</a></h2>
<p>The <code>auth</code> module contains a default authorization model and configuration inspired by the AWS IAM 
Policies and Roles model. The following is a brief overview of the model.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The <code>auth</code> module provides a reusable struct model and <code>Authorizer</code> trait that can be used with any datastore in the case
that you need to role your own RBAC. It is based on the AWS IAM model. The <code>Authorizer</code> trait is decoupled from the
underlying datastore. Consumers of this crate have to implement their own data storage/access strategy. See the
<code>DefaultAuthorizer</code> in the <code>mongo</code> package in this crate for an example.</p>
<p>See the <code>mongodb.auth.init_default_auth</code> module for a re-usable database migration that will initialize
an opinionated authorization configuration.</p>
<p><img src="SDK/platform/auth-overview.png" alt="Auth Overview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-crate"><a class="header" href="#core-crate">Core Crate</a></h2>
<p>The <code>core</code> crate contains reusable functionality related to the fundamental Harbor domain. This
crate defines default and mandatory behaviors and enforces all rules related to data integrity. 
Community members that are developing their own custom extensions or who wish to contribute to 
upstream Harbor are encouraged to review the code in this crate, and take care not to perform data
mutations that are incompatible with upstream Harbor. Community members should likely leverage
the services defined in this crate as-is, or interact with the API.</p>
<p>The two built-in consumers of the <code>core</code> crate are the <em><em>Enrichment Engine</em></em> and the <em><em>API</em></em>.</p>
<h3 id="enrichment-engine"><a class="header" href="#enrichment-engine">Enrichment Engine</a></h3>
<p>The <em><strong>Enrichment Engine</strong></em> is:</p>
<ul>
<li>A set of <strong>providers</strong> that perform <strong>tasks</strong> that either manage <strong>entities</strong> (i.e. data) or 
perform other functions necessary for Harbor to operate.</li>
<li>The custom logic for a <strong>task</strong> is contained in a type that implements the <code>TaskProvider</code> trait. </li>
<li>The <code>cli</code> binary is the default mechanism for executing a <code>TaskProvider</code>.</li>
<li><code>TaskProvider</code> types call <strong>services</strong> from the <code>core</code> crate to perform persistence 
operations or domain functions such as uploading an SBOM.</li>
<li>The default functions defined in the <code>TaskProvider</code> trait are responsible for reporting task 
outcome/status, and collecting error information.</li>
<li>The <code>run</code> function in a <code>TaskProvider</code> is responsible for executing <strong>task specific</strong> logic that 
usually involves invoking or more <strong>services</strong> that mutate the data store.</li>
<li>A <code>Service</code> wraps a shared <code>Store</code> instance and coordinates entity validation, persistence, 
and relationships.</li>
</ul>
<p>The diagram below illustrates this flow of activities.</p>
<p><img src="SDK/core/enrichment-engine-sequence.png" alt="Enrichment Engine Sequence Diagram" /></p>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>The <em><strong>API</strong></em> is:</p>
<ul>
<li>A single binary that configures dependency injection, tracing, and error handling, and 
then starts an HTTP listener.</li>
<li>The listener decodes payloads, enforces authz, and routes requests to handlers that are 
implemented as <code>controllers</code>.</li>
<li>A <code>controller</code> calls <strong>services</strong> from the <code>core</code> crate to perform persistence operations or other 
domain functions such as ingesting an SBOM.</li>
<li>A <code>Service</code> wraps a shared <code>Store</code> instance and coordinates entity validation, persistence,
and relationships.</li>
</ul>
<p>The diagram below illustrates this flow of activities.</p>
<p><img src="SDK/core/api-sequence.png" alt="API Sequence Diagram" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p><strong>Entities</strong> are types that either define the data elements being observed in the Harbor problem 
domain, or support interaction across services, both internal and external. Most entities are 
persisted as entries in a data store. However, some entities are materialized at runtime only for 
the purpose of executing domain logic, and are never serialized or persisted. Entities are typically 
managed by one or more <strong>services</strong>.</p>
<p>Entities may also contain validation or helper functions that can operate on an instance of an entity.
Consider the following. In this example, the <code>Token</code> entity defines a function (<code>expired</code>) that 
provides a consistent, functional mechanism for determining if a <code>Token</code> instance has expired.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use harbcore::Error;

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Token {
    pub id: String,
    pub name: String,
    pub token: String,
    pub enabled: bool,
    pub expires: String,
}

impl Token {
    pub fn expired(&amp;self) -&gt; Result&lt;bool, Error&gt; {
        if self.expires.is_empty() {
            return Ok(false);
        }

        match DateTime::parse_from_rfc3339(&amp;self.expires) {
            Ok(expiry) =&gt; Ok(Utc::now() &gt;= expiry),
            Err(err) =&gt; Err(Error::Runtime(format!(&quot;error parsing token expires: {}&quot;, err.to_string()))),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="services"><a class="header" href="#services">Services</a></h2>
<p>A <strong>service</strong> in the Harbor component model can be thought of as a set of behaviors (i.e.
functions) that relate to a specific part of the problem domain or subsystem. Some services 
reference others and act as coordinators across multiple areas of the domain. Services typically 
contain some sort of shared state, whether it be a set of entities or configuration data.</p>
<p>Examples of grouping functionality by service:</p>
<ul>
<li>Provide data access for a single entity or a family of entities</li>
<li>Provide access to an external system</li>
<li>Translate between external models and internal entities</li>
<li>Coordinate activities for a task</li>
<li>Wrap an instance of a resource that is expensive to create so that it can be reused across 
loop iterations or functional boundaries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>The concept of a <strong>provider</strong> is fundamental to the design of Harbor. The term provider has become 
synonymous with the <a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a> 
popularized by the Gang of Four in their seminal book <a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable 
Object-Oriented Software</a>. The basic idea behind 
a provider is that you can define an abstract interface, or trait in Rust terminology, and 
types that implement that trait can vary in terms of the algorithm they apply internally when 
called. This is very useful in scenarios where you have a finite set of operations that you want to 
perform, but you want to be able to swap out the concrete implementation based on some context.</p>
<p>The <code>TaskProvider</code> trait is an example of a provider that you can use. With this trait, Harbor 
can be extended with new tasks that fit within the model, and can be swapped based on parameters 
or configuration. See the <code>cli</code> crate for more concrete examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<p>A <code>Task</code> records that an instance of a process was run in a Harbor environment. It may be helpful to
think of a task as unit of work. The enrichment engine is implemented as a set of services that 
implement the <code>TaskProvider</code> trait. You can build a service that implements the <code>TaskProvider</code> 
trait and unless you override the key default functions, Harbor will record details about each 
instantiation of the process by storing an instance of a <code>Task</code> entity.</p>
<p>The <code>TaskProvider</code> trait has the following interface. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TaskProvider: Service&lt;Task&gt; {
    /// Implement this with your custom logic.
    async fn run(&amp;self, task: &amp;mut Task) -&gt; Result&lt;HashMap&lt;String, String&gt;, Error&gt;;

    /// Runs the task and store the results. Usually invoked by a CLI command handler.
    async fn execute(&amp;self, task: &amp;mut Task) -&gt; Result&lt;(), Error&gt; {
        // See codebase for default implementation. You should probably not need to override this.
    }

    /// Inserts the [Task] record at the start of the task run.
    async fn init(&amp;self, task: &amp;mut Task) -&gt; Result&lt;(), Error&gt; {
        // See codebase for default implementation. You should probably not need to override this.
    }

    /// Updates the [Task] record at the end of the task run.
    async fn complete(&amp;self, task: &amp;mut Task) -&gt; Result&lt;(), Error&gt; {
        // See codebase for default implementation. You should probably not need to override this.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The default implementations of the <code>execute</code>, <code>init</code>, and<code>complete</code> functions provide a consistent 
way to track and debug <code>Task</code> services. Contributors most likely only need to implement the <code>run</code> 
function. This is where task specific logic runs.</p>
<p>Running a <code>TaskProvider</code> should be limited to calling the <code>execute</code> function as illustrated below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task_provider = TaskProvider {};
task_provider.execute(task);
<span class="boring">}</span></code></pre></pre>
<p>Review existing <code>TaskProvider</code> implementations for example of how to implement a <code>TaskProvider</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vendor-management-1"><a class="header" href="#vendor-management-1">Vendor Management</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Manual SBOM upload screen (under development)</li>
<li><input disabled="" type="checkbox"/>
Role-based permissions related to SBOM upload screen (under development)</li>
<li><input disabled="" type="checkbox"/>
Vendor SBOM staleness/freshness policy tracking and enforcement (research &amp; development)</li>
<li><input disabled="" type="checkbox"/>
Machine to machine vendor upload mechanism (research)</li>
</ul>
<h3 id="sbom-generation-and-synchronization"><a class="header" href="#sbom-generation-and-synchronization">SBOM generation and synchronization</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Snyk</li>
<li><input disabled="" type="checkbox" checked=""/>
GitHub Action (POC)</li>
<li><input disabled="" type="checkbox"/>
GitHub (in progress)</li>
<li><input disabled="" type="checkbox"/>
GitLab</li>
<li><input disabled="" type="checkbox"/>
Bitbucket</li>
<li><input disabled="" type="checkbox"/>
Syft</li>
<li><input disabled="" type="checkbox"/>
Ion Channel</li>
</ul>
<h3 id="sbom-storage"><a class="header" href="#sbom-storage">SBOM storage</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
S3</li>
<li><input disabled="" type="checkbox" checked=""/>
File system</li>
</ul>
<h3 id="enrichment-1"><a class="header" href="#enrichment-1">Enrichment</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Snyk</li>
<li><input disabled="" type="checkbox" checked=""/>
EPSS</li>
<li><input disabled="" type="checkbox" checked=""/>
sbom-scorecard</li>
<li><input disabled="" type="checkbox"/>
Ion Channel</li>
<li><input disabled="" type="checkbox"/>
OSV</li>
</ul>
<h3 id="analytics"><a class="header" href="#analytics">Analytics</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Vulnerabilities and scores by SBOM</li>
<li><input disabled="" type="checkbox"/>
Dependency blast radius</li>
<li><input disabled="" type="checkbox"/>
SBOM freshness</li>
<li><input disabled="" type="checkbox"/>
CI/CD &amp; Runtime monitoring</li>
</ul>
<h3 id="technical-improvements"><a class="header" href="#technical-improvements">Technical Improvements</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
SPDX support</li>
<li><input disabled="" type="checkbox"/>
Pipeline Metrics (e.g. OTEL, Prometheus, Grafana)</li>
<li><input disabled="" type="checkbox"/>
Cargo features</li>
<li><input disabled="" type="checkbox"/>
Notifications</li>
<li><input disabled="" type="checkbox"/>
CI/CD integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Harbor is an Open Source project funded by the [Centers for Medicare and Medicaid Services]
(https://www.cms.gov/) as part of their <a href="https://www.cms.gov/tra/Content/Application_Development/AD_0220_Open_Source_Strategy.htm">Open Source Strategy</a>.
The Harbor team is grateful for their sponsorship and guidance.</p>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>Harbor generally adopts the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>.</p>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>Harbor welcomes PRs from the community! Specific areas we could use community contributions 
include but are not limited to:</p>
<ul>
<li>Test coverage!</li>
<li>Bug fixes</li>
<li>New enrichment providers</li>
<li>Documentation updates and additions</li>
<li>Additional data storage providers</li>
<li>Infrastructure-as-Code examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="design-guidelines"><a class="header" href="#design-guidelines">Design Guidelines</a></h2>
<p>The following sections contain a non-exhaustive list of design guidelines to consider when 
contributing to Harbor. Suggestions for additional guiding principles welcome!</p>
<h2 id="repository-organization"><a class="header" href="#repository-organization">Repository Organization</a></h2>
<pre><code class="language-ascii">root/
   api/          # HTTP API
   cli/          # Enrichment Engine
   extensions/   # Custom logic specific to a Harbor instance
   sdk/          # Automation and developer oriented tooling
     core/         # Component Model and Domain Logic  
     platform/     # Infrastructure and generically reusable code
</code></pre>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>Subdirectories are the unit of modularization in Rust. They should contain a <code>mod.rs</code> file and this 
file should contain exports, unit tests, and types that are shared or fundamental to the module as 
a whole. </p>
<blockquote>
<p>Examples of fundamental types include:</p>
<ul>
<li>Enums</li>
<li>Traits</li>
<li>Errors</li>
</ul>
</blockquote>
<h3 id="platform"><a class="header" href="#platform">Platform</a></h3>
<p>Code in the <code>platform</code> crate is intended to be entirely generic and unrelated to the Harbor 
application. It should be thought of as a separate reusable library that can be leveraged by any 
application. When contributing or reviewing new features or modifications to the <code>platform</code>crate 
it is imperative to keep this in mind.</p>
<h3 id="services-1"><a class="header" href="#services-1">Services</a></h3>
<ul>
<li>Services can consume external models or types but should not expose them outside the crate 
boundary. Make sure your service exposes only Harbor entities outside the crate.</li>
<li>If a function does not rely on shared state, consider making it a module level function 
instead. It will likely be easier to test.</li>
<li>If you need to repeatedly use a type that is expensive to create, such as an TLS-enabled HTTP 
Client or a DB driver that establishes long-lived connections, consider wrapping it in a service.</li>
</ul>
<h3 id="task-providers"><a class="header" href="#task-providers">Task Providers</a></h3>
<p>Some specific things to consider when designing a <code>TaskProvider</code> are:</p>
<ul>
<li>What kind of task is it?
<ul>
<li>Can one of the existing enumerations be extended or is it an altogether new thing?</li>
<li>Tasks typically map to a <code>cli</code> command. Does the new task naturally fit under an existing 
command or is a new command needed?</li>
</ul>
</li>
<li>If you experience and unrecoverable error, make sure to set the error message on the <code>Task</code> entity
so that the <code>Task.Status</code> is set to <code>failed</code>.</li>
<li>Can the task tolerate partial failures?
<ul>
<li>If so, add errors to the <code>Task</code> entity to debug recoverable errors during a task run.</li>
<li>If not, set the error message on the <code>Task</code> entity so that the <code>Task.Status</code> is set to <code>failed</code>.</li>
</ul>
</li>
<li>Should affected entities maintain a reference to <code>Task</code> instances?
<ul>
<li>If so, add <code>task_refs</code> entries to entities affected by a run of a <code>TaskProvider</code> instance.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
