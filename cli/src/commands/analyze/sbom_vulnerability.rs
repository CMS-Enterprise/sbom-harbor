use crate::commands::analyze::AnalyzeArgs;
use crate::common::pretty_print_json;
use crate::{Error, OutputFormat};
use clap::Parser;
use harbcore::services::analytics::sboms::service::AnalyticService;
use platform::persistence::mongodb::Store;
use std::sync::Arc;

/// Args for generating a Detailed Report
#[derive(Clone, Debug, Parser)]
pub struct VulnerabilityArgs {
    /// The output format for the result. Defaults to JSON.
    #[arg(long)]
    format: Option<OutputFormat>,

    /// Optional output directory to save output to. If none specified, results will be written
    /// to stdout.
    output: Option<String>,

    /// File name to save output to. If none specified, defaults to either
    /// `sbom-vulnerability.json` or `sbom-vulnerability.csv` depending on which output format
    /// was specified. Ignored if `output` not set.
    file_name: Option<String>,
}

/// Run the logic to satisfy the `sbom-vulnerability` command.
pub(crate) async fn execute(args: &AnalyzeArgs) -> Result<(), Error> {
    let debug = args.debug;
    let args = match &args.vulnerability_args {
        None => {
            return Err(Error::InvalidArg("vulnerability args required".to_string()));
        }
        Some(args) => args,
    };

    let cx = match debug {
        false => harbcore::config::harbor_context().map_err(|e| Error::Config(e.to_string()))?,
        true => harbcore::config::dev_context(None).map_err(|e| Error::Config(e.to_string()))?,
    };

    let store = Arc::new(
        Store::new(&cx)
            .await
            .map_err(|e| Error::Analyze(e.to_string()))?,
    );

    let service = AnalyticService::new(store, None);

    let summaries = service.sbom_vulnerabilities().await?;

    let format = match &args.format {
        None => OutputFormat::Json,
        Some(f) => f.clone(),
    };

    let output_text = crate::common::analytics::format_sbom_summaries(summaries, &format)?;

    match &args.file_name {
        None => match format {
            OutputFormat::Json => {
                pretty_print_json(output_text.as_str());
            }
            _ => {
                println!("{}", output_text);
            }
        },
        Some(file_name) => {
            std::fs::write(file_name, output_text)
                .map_err(|e| Error::Analyze(format!("error writing results to file: {}", e)))?;
        }
    }

    Ok(())
}
